"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Import necessary models and services
const transaction_1 = __importDefault(require("../models/transaction"));
const bookService_1 = __importDefault(require("./bookService"));
const userService_1 = __importDefault(require("./userService"));
/**
 * Issues a book to a user by creating a transaction.
 *
 * @param data - The data required to issue a book, including book name, user ID or name, and issue date
 * @returns The created transaction document
 * @throws Error if the book cannot be issued
 */
const issueBook = (data) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const book = yield bookService_1.default.findOneByName(data.bookName);
        const user = yield userService_1.default.findOneByNameOrId(data.userIdOrName);
        const transaction = new transaction_1.default({
            bookId: book._id,
            userId: user._id,
            issueDate: new Date(data.issueDate),
        });
        yield transaction.save();
        return transaction;
    }
    catch (error) {
        throw new Error(`Unable to issue book: ${error.message}`);
    }
});
/**
 * Returns a book by updating the transaction with a return date and calculating total rent.
 *
 * @param data - The data required to return a book, including book name, user ID or name, and return date
 * @returns The updated transaction document
 * @throws Error if the book cannot be returned
 */
const returnBook = (data) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const book = yield bookService_1.default.findOneByName(data.bookName);
        const user = yield userService_1.default.findOneByNameOrId(data.userIdOrName);
        const transaction = yield transaction_1.default.findOne({
            bookId: book._id,
            userId: user._id,
            returnDate: { $exists: false },
        });
        if (!transaction) {
            throw new Error("Transaction not found or book already returned");
        }
        transaction.returnDate = new Date();
        transaction.totalRent = calculateTotalRent(transaction.issueDate, transaction.returnDate, book.rentPerDay);
        yield transaction.save();
        return transaction;
    }
    catch (error) {
        throw new Error(`Unable to return book: ${error.message}`);
    }
});
/**
 * Retrieves the status of a book, including total issued count and current issuance status.
 *
 * @param bookName - The name of the book to check status for
 * @returns An object containing the total issued count, current issuance status, and users who issued the book
 * @throws Error if the book status cannot be retrieved
 */
const bookStatus = (bookName) => __awaiter(void 0, void 0, void 0, function* () {
    if (!bookName) {
        throw new Error("Book name is required");
    }
    try {
        const book = yield bookService_1.default.findOneByName(bookName);
        const transactions = yield transaction_1.default.find({ bookId: book._id });
        if (transactions.length === 0)
            throw new Error("No transactions found for this book: " + bookName);
        const currentlyIssued = transactions.find((transaction) => !transaction.returnDate);
        const usersWhoIssued = transactions.map((transaction) => transaction.userId);
        return {
            totalIssuedCount: transactions.length,
            currentlyIssued: currentlyIssued
                ? currentlyIssued.userId
                : "Not issued at the moment",
            usersWhoIssued,
        };
    }
    catch (error) {
        throw new Error("Error in fetching bookStatus: " + error.message);
    }
});
/**
 * Calculates the total revenue generated by a book based on completed transactions.
 *
 * @param bookName - The name of the book to calculate revenue for
 * @returns The total revenue generated by the book
 * @throws Error if the revenue cannot be calculated
 */
const bookRevenue = (bookName) => __awaiter(void 0, void 0, void 0, function* () {
    if (!bookName) {
        throw new Error("Book name is required");
    }
    try {
        const book = yield bookService_1.default.findOneByName(bookName);
        if (!book) {
            throw new Error("Book not found: " + bookName);
        }
        const transactions = yield transaction_1.default.find({ bookId: book._id });
        if (transactions.length === 0) {
            throw new Error("No revenue generated by book: " + bookName);
        }
        const totalRevenue = transactions.reduce((acc, transaction) => {
            return acc + (transaction.totalRent || 0);
        }, 0);
        return totalRevenue;
    }
    catch (error) {
        console.error("Error calculating book revenue: ", error.message);
        throw error;
    }
});
/**
 * Retrieves the list of books issued to a specific user.
 *
 * @param userIdOrName - The ID or name of the user to find books for
 * @returns An array of books issued to the user
 * @throws Error if the books cannot be retrieved
 */
const getBooksIssuedToUser = (userIdOrName) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const user = yield userService_1.default.findOneByNameOrId(userIdOrName);
        if (!user) {
            throw new Error("User not found");
        }
        const transactions = yield transaction_1.default.find({
            userId: user._id,
        }).populate("bookId");
        return transactions.map((transaction) => ({
            bookName: transaction.bookId.bookName,
            issueDate: transaction.issueDate,
            returnDate: transaction.returnDate,
        }));
    }
    catch (error) {
        throw new Error(`Unable to retrieve books for user: ${error.message}`);
    }
});
/**
 * Retrieves the list of books issued within a specified date range.
 *
 * @param startDate - The start date of the range
 * @param endDate - The end date of the range
 * @returns An array of books issued within the date range
 * @throws Error if the books cannot be retrieved
 */
const getBooksIssuedInDateRange = (startDate, endDate) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const transactions = yield transaction_1.default.find({
            issueDate: { $gte: startDate, $lte: endDate },
        }).populate("bookId userId");
        return transactions.map((transaction) => ({
            bookName: transaction.bookId.bookName,
            issuedTo: transaction.userId.name,
            issueDate: transaction.issueDate,
        }));
    }
    catch (error) {
        throw new Error(`Unable to retrieve books for date range: ${error.message}`);
    }
});
/**
 * Helper function to calculate total rent based on issue and return dates.
 *
 * @param issueDate - The date the book was issued
 * @param returnDate - The date the book was returned
 * @param rentPerDay - The daily rent rate for the book
 * @returns The total rent calculated for the rental period
 */
const calculateTotalRent = (issueDate, returnDate, rentPerDay) => {
    const daysRented = Math.ceil((returnDate.getTime() - issueDate.getTime()) / (1000 * 3600 * 24));
    return daysRented * rentPerDay;
};
/**
 * Creates dummy transactions for testing purposes by issuing and returning books.
 *
 * @returns An object containing arrays of issued and returned transactions
 */
const createDummyTransations = () => __awaiter(void 0, void 0, void 0, function* () {
    const books = yield bookService_1.default.findBooks();
    const users = yield userService_1.default.getAllUsers();
    const generateIssueDate = () => {
        return new Date();
    };
    const transactions = [];
    const returnTransactions = [];
    for (let i = 0; i < 40; i++) {
        const book = books[i % books.length];
        const user = users[i % users.length];
        const issueDate = generateIssueDate();
        const issueTransaction = {
            bookName: book.bookName,
            userIdOrName: user.name,
            issueDate: issueDate,
        };
        const returnTransaction = {
            bookName: book.bookName,
            userIdOrName: user.name,
            returnDate: new Date(issueDate.getTime() + 7 * 24 * 60 * 60 * 1000),
        };
        const issuedTransaction = yield issueBook(issueTransaction);
        const returnedTransaction = yield returnBook(returnTransaction);
        transactions.push(issuedTransaction);
        returnTransactions.push(returnTransaction);
    }
    return { transactions, returnTransactions };
});
// Export the service functions for use in controllers
exports.default = {
    issueBook,
    returnBook,
    createDummyTransations,
    bookStatus,
    bookRevenue,
    getBooksIssuedInDateRange,
    getBooksIssuedToUser,
};
