"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// src/services/transactionService.ts
const transaction_1 = __importDefault(require("../models/transaction"));
const bookService_1 = __importDefault(require("./bookService"));
const userService_1 = __importDefault(require("./userService"));
const issueBook = (data) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Find the book by name
        const book = yield bookService_1.default.findOneByName(data.bookName);
        // Find the user by userId or name
        const user = yield userService_1.default.findOneByNameOrId(data.userIdOrName);
        // Create a new transaction
        const transaction = new transaction_1.default({
            bookId: book._id,
            userId: user._id,
            issueDate: new Date(data.issueDate),
        });
        yield transaction.save();
        return transaction;
    }
    catch (error) {
        throw new Error(`Unable to issue book: ${error.message}`);
    }
});
const returnBook = (data) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Find the book by name
        const book = yield bookService_1.default.findOneByName(data.bookName);
        // Find the user by userId or name
        const user = yield userService_1.default.findOneByNameOrId(data.userIdOrName);
        // find transaction
        const transaction = yield transaction_1.default.findOne({
            bookId: book._id,
            userId: user._id,
            returnDate: { $exists: false }, // Ensure the book hasn't been returned yet
        });
        if (!transaction) {
            throw new Error("Transaction not found or book already returned");
        }
        transaction.returnDate = new Date();
        transaction.totalRent = calculateTotalRent(transaction.issueDate, transaction.returnDate, book.rentPerDay);
        yield transaction.save();
        return transaction;
    }
    catch (error) {
        throw new Error(`Unable to return book: ${error.message}`);
    }
});
const bookStatus = (bookName) => __awaiter(void 0, void 0, void 0, function* () {
    if (!bookName) {
        throw new Error("Book name is required");
    }
    try {
        // Find all transactions for the given book name
        const book = yield bookService_1.default.findOneByName(bookName);
        const transactions = yield transaction_1.default.find({ bookId: book._id });
        if (transactions.length === 0)
            throw new Error("No transactions found for this book: " + bookName);
        // Find currently issued transaction (where returnDate is null)
        const currentlyIssued = transactions.find((transaction) => !transaction.returnDate);
        // Get list of all users who have issued the book
        const usersWhoIssued = transactions.map((transaction) => transaction.userId);
        return {
            totalIssuedCount: transactions.length,
            currentlyIssued: currentlyIssued
                ? currentlyIssued.userId
                : "Not issued at the moment",
            usersWhoIssued,
        };
    }
    catch (error) {
        throw new Error("Error in fetching bookStatus: " + error.message);
    }
});
const bookRevenue = (bookName) => __awaiter(void 0, void 0, void 0, function* () {
    if (!bookName) {
        throw new Error("Book name is required");
    }
    try {
        // Find the book by name
        const book = yield bookService_1.default.findOneByName(bookName);
        if (!book) {
            throw new Error("Book not found: " + bookName);
        }
        // Find all transactions for the given book ID
        const transactions = yield transaction_1.default.find({ bookId: book._id });
        if (transactions.length === 0) {
            throw new Error("No revenue generated by book: " + bookName);
        }
        // Calculate total revenue
        const totalRevenue = transactions.reduce((acc, transaction) => {
            return acc + (transaction.totalRent || 0);
        }, 0);
        return totalRevenue;
    }
    catch (error) {
        console.error("Error calculating book revenue: ", error.message);
        throw error;
    }
});
const getBooksIssuedToUser = (userIdOrName) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const user = yield userService_1.default.findOneByNameOrId(userIdOrName);
        if (!user) {
            throw new Error("User not found");
        }
        const transactions = yield transaction_1.default.find({
            userId: user._id,
        }).populate("bookId");
        return transactions.map((transaction) => ({
            bookName: transaction.bookId.bookName,
            issueDate: transaction.issueDate,
            returnDate: transaction.returnDate,
        }));
    }
    catch (error) {
        throw new Error(`Unable to retrieve books for user: ${error.message}`);
    }
});
const getBooksIssuedInDateRange = (startDate, endDate) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const transactions = yield transaction_1.default.find({
            issueDate: { $gte: startDate, $lte: endDate },
        }).populate("bookId userId");
        return transactions.map((transaction) => ({
            bookName: transaction.bookId.bookName,
            issuedTo: transaction.userId.name,
            issueDate: transaction.issueDate,
        }));
    }
    catch (error) {
        throw new Error(`Unable to retrieve books for date range: ${error.message}`);
    }
});
// Helper function to calculate total rent
const calculateTotalRent = (issueDate, returnDate, rentPerDay) => {
    const daysRented = Math.ceil((returnDate.getTime() - issueDate.getTime()) / (1000 * 3600 * 24));
    return daysRented * rentPerDay;
};
// If you want to create some dummy transactions (i.e issue books and return them)
const createDummyTransations = () => __awaiter(void 0, void 0, void 0, function* () {
    const books = yield bookService_1.default.findBooks();
    const users = yield userService_1.default.getAllUsers();
    const generateIssueDate = () => {
        return new Date();
    };
    const transactions = [];
    const returnTransactions = [];
    for (let i = 0; i < 40; i++) {
        const book = books[i % books.length];
        const user = users[i % users.length];
        const issueDate = generateIssueDate();
        const issueTransaction = {
            bookName: book.bookName,
            userIdOrName: user.name,
            issueDate: issueDate,
        };
        const returnTransaction = {
            bookName: book.bookName,
            userIdOrName: user.name,
            returnDate: new Date(issueDate.getTime() + 7 * 24 * 60 * 60 * 1000), // Assuming a 7-day rental period
        };
        const issuedTransaction = yield issueBook(issueTransaction);
        const returnedTransaction = yield returnBook(returnTransaction);
        transactions.push(issuedTransaction);
        returnTransactions.push(returnedTransaction);
    }
    return { transactions, returnTransactions };
});
exports.default = {
    issueBook,
    returnBook,
    createDummyTransations,
    bookStatus,
    bookRevenue,
    getBooksIssuedInDateRange,
    getBooksIssuedToUser,
};
