// Import necessary models and services
import Transaction from "../models/transaction";
import bookService from "./bookService";
import userService from "./userService";
/**
 * Issues a book to a user by creating a transaction.
 *
 * @param data - The data required to issue a book, including book name, user ID or name, and issue date
 * @returns The created transaction document
 * @throws Error if the book cannot be issued
 */
const issueBook = async (data) => {
    try {
        const book = await bookService.findOneByName(data.bookName);
        const user = await userService.findOneByNameOrId(data.userIdOrName);
        const transaction = new Transaction({
            bookId: book._id,
            userId: user._id,
            issueDate: new Date(data.issueDate),
        });
        await transaction.save();
        return transaction;
    }
    catch (error) {
        throw new Error(`Unable to issue book: ${error.message}`);
    }
};
/**
 * Returns a book by updating the transaction with a return date and calculating total rent.
 *
 * @param data - The data required to return a book, including book name, user ID or name, and return date
 * @returns The updated transaction document
 * @throws Error if the book cannot be returned
 */
const returnBook = async (data) => {
    try {
        const book = await bookService.findOneByName(data.bookName);
        const user = await userService.findOneByNameOrId(data.userIdOrName);
        const transaction = await Transaction.findOne({
            bookId: book._id,
            userId: user._id,
            returnDate: { $exists: false },
        });
        if (!transaction) {
            throw new Error("Transaction not found or book already returned");
        }
        transaction.returnDate = new Date();
        transaction.totalRent = calculateTotalRent(transaction.issueDate, transaction.returnDate, book.rentPerDay);
        await transaction.save();
        return transaction;
    }
    catch (error) {
        throw new Error(`Unable to return book: ${error.message}`);
    }
};
/**
 * Retrieves the status of a book, including total issued count and current issuance status.
 *
 * @param bookName - The name of the book to check status for
 * @returns An object containing the total issued count, current issuance status, and users who issued the book
 * @throws Error if the book status cannot be retrieved
 */
const bookStatus = async (bookName) => {
    if (!bookName) {
        throw new Error("Book name is required");
    }
    try {
        const book = await bookService.findOneByName(bookName);
        const transactions = await Transaction.find({ bookId: book._id });
        if (transactions.length === 0)
            throw new Error("No transactions found for this book: " + bookName);
        const currentlyIssued = transactions.find((transaction) => !transaction.returnDate);
        const usersWhoIssued = transactions.map((transaction) => transaction.userId);
        return {
            totalIssuedCount: transactions.length,
            currentlyIssued: currentlyIssued
                ? currentlyIssued.userId
                : "Not issued at the moment",
            usersWhoIssued,
        };
    }
    catch (error) {
        throw new Error("Error in fetching bookStatus: " + error.message);
    }
};
/**
 * Calculates the total revenue generated by a book based on completed transactions.
 *
 * @param bookName - The name of the book to calculate revenue for
 * @returns The total revenue generated by the book
 * @throws Error if the revenue cannot be calculated
 */
const bookRevenue = async (bookName) => {
    if (!bookName) {
        throw new Error("Book name is required");
    }
    try {
        const book = await bookService.findOneByName(bookName);
        if (!book) {
            throw new Error("Book not found: " + bookName);
        }
        const transactions = await Transaction.find({ bookId: book._id });
        if (transactions.length === 0) {
            throw new Error("No revenue generated by book: " + bookName);
        }
        const totalRevenue = transactions.reduce((acc, transaction) => {
            return acc + (transaction.totalRent || 0);
        }, 0);
        return totalRevenue;
    }
    catch (error) {
        console.error("Error calculating book revenue: ", error.message);
        throw error;
    }
};
/**
 * Retrieves the list of books issued to a specific user.
 *
 * @param userIdOrName - The ID or name of the user to find books for
 * @returns An array of books issued to the user
 * @throws Error if the books cannot be retrieved
 */
const getBooksIssuedToUser = async (userIdOrName) => {
    try {
        const user = await userService.findOneByNameOrId(userIdOrName);
        if (!user) {
            throw new Error("User not found");
        }
        const transactions = await Transaction.find({
            userId: user._id,
        }).populate("bookId");
        return transactions.map((transaction) => ({
            bookName: transaction.bookId.bookName,
            issueDate: transaction.issueDate,
            returnDate: transaction.returnDate,
        }));
    }
    catch (error) {
        throw new Error(`Unable to retrieve books for user: ${error.message}`);
    }
};
/**
 * Retrieves the list of books issued within a specified date range.
 *
 * @param startDate - The start date of the range
 * @param endDate - The end date of the range
 * @returns An array of books issued within the date range
 * @throws Error if the books cannot be retrieved
 */
const getBooksIssuedInDateRange = async (startDate, endDate) => {
    try {
        const transactions = await Transaction.find({
            issueDate: { $gte: startDate, $lte: endDate },
        }).populate("bookId userId");
        return transactions.map((transaction) => ({
            bookName: transaction.bookId.bookName,
            issuedTo: transaction.userId.name,
            issueDate: transaction.issueDate,
        }));
    }
    catch (error) {
        throw new Error(`Unable to retrieve books for date range: ${error.message}`);
    }
};
/**
 * Helper function to calculate total rent based on issue and return dates.
 *
 * @param issueDate - The date the book was issued
 * @param returnDate - The date the book was returned
 * @param rentPerDay - The daily rent rate for the book
 * @returns The total rent calculated for the rental period
 */
const calculateTotalRent = (issueDate, returnDate, rentPerDay) => {
    const daysRented = Math.ceil((returnDate.getTime() - issueDate.getTime()) / (1000 * 3600 * 24));
    return daysRented * rentPerDay;
};
/**
 * Creates dummy transactions for testing purposes by issuing and returning books.
 *
 * @returns An object containing arrays of issued and returned transactions
 */
const createDummyTransations = async () => {
    const books = await bookService.findBooks();
    const users = await userService.getAllUsers();
    const generateIssueDate = () => {
        return new Date();
    };
    const transactions = [];
    const returnTransactions = [];
    for (let i = 0; i < 40; i++) {
        const book = books[i % books.length];
        const user = users[i % users.length];
        const issueDate = generateIssueDate();
        const issueTransaction = {
            bookName: book.bookName,
            userIdOrName: user.name,
            issueDate: issueDate,
        };
        const returnTransaction = {
            bookName: book.bookName,
            userIdOrName: user.name,
            returnDate: new Date(issueDate.getTime() + 7 * 24 * 60 * 60 * 1000),
        };
        const issuedTransaction = await issueBook(issueTransaction);
        const returnedTransaction = await returnBook(returnTransaction);
        transactions.push(issuedTransaction);
        returnTransactions.push(returnTransaction);
    }
    return { transactions, returnTransactions };
};
// Export the service functions for use in controllers
export default {
    issueBook,
    returnBook,
    createDummyTransations,
    bookStatus,
    bookRevenue,
    getBooksIssuedInDateRange,
    getBooksIssuedToUser,
};
