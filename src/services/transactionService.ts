// Import necessary models and services
import Transaction from "../models/transaction";
import bookService from "./bookService";
import userService from "./userService";

// Interface for issuing a book
interface IIssueBook {
  bookName: string;
  userIdOrName: string;
  issueDate: Date;
}

/**
 * Issues a book to a user by creating a transaction.
 *
 * @param data - The data required to issue a book, including book name, user ID or name, and issue date
 * @returns The created transaction document
 * @throws Error if the book cannot be issued
 */
const issueBook = async (data: IIssueBook) => {
  try {
    const book = await bookService.findOneByName(data.bookName);
    const user = await userService.findOneByNameOrId(data.userIdOrName);

    const transaction = new Transaction({
      bookId: book._id,
      userId: user._id,
      issueDate: new Date(data.issueDate),
    });

    await transaction.save();
    return transaction;
  } catch (error: any) {
    throw new Error(`Unable to issue book: ${error.message}`);
  }
};

// Interface for returning a book
interface IReturnBook {
  bookName: string;
  userIdOrName: string;
  returnDate: Date;
}

/**
 * Returns a book by updating the transaction with a return date and calculating total rent.
 *
 * @param data - The data required to return a book, including book name, user ID or name, and return date
 * @returns The updated transaction document
 * @throws Error if the book cannot be returned
 */
const returnBook = async (data: IReturnBook) => {
  try {
    const book = await bookService.findOneByName(data.bookName);
    const user = await userService.findOneByNameOrId(data.userIdOrName);

    const transaction = await Transaction.findOne({
      bookId: book._id,
      userId: user._id,
      returnDate: { $exists: false },
    });

    if (!transaction) {
      throw new Error("Transaction not found or book already returned");
    }

    transaction.returnDate = new Date();
    transaction.totalRent = calculateTotalRent(
      transaction.issueDate,
      transaction.returnDate,
      book.rentPerDay
    );

    await transaction.save();
    return transaction;
  } catch (error: any) {
    throw new Error(`Unable to return book: ${error.message}`);
  }
};

/**
 * Retrieves the status of a book, including total issued count and current issuance status.
 *
 * @param bookName - The name of the book to check status for
 * @returns An object containing the total issued count, current issuance status, and users who issued the book
 * @throws Error if the book status cannot be retrieved
 */
const bookStatus = async (bookName: string) => {
  if (!bookName) {
    throw new Error("Book name is required");
  }
  try {
    const book = await bookService.findOneByName(bookName);
    const transactions = await Transaction.find({ bookId: book._id });

    if (transactions.length === 0)
      throw new Error("No transactions found for this book: " + bookName);

    const currentlyIssued = transactions.find(
      (transaction: any) => !transaction.returnDate
    );

    const usersWhoIssued = transactions.map(
      (transaction: any) => transaction.userId
    );

    return {
      totalIssuedCount: transactions.length,
      currentlyIssued: currentlyIssued
        ? currentlyIssued.userId
        : "Not issued at the moment",
      usersWhoIssued,
    };
  } catch (error: any) {
    throw new Error("Error in fetching bookStatus: " + error.message);
  }
};

/**
 * Calculates the total revenue generated by a book based on completed transactions.
 *
 * @param bookName - The name of the book to calculate revenue for
 * @returns The total revenue generated by the book
 * @throws Error if the revenue cannot be calculated
 */
const bookRevenue = async (bookName: string) => {
  if (!bookName) {
    throw new Error("Book name is required");
  }
  try {
    const book = await bookService.findOneByName(bookName);
    if (!book) {
      throw new Error("Book not found: " + bookName);
    }

    const transactions = await Transaction.find({ bookId: book._id });

    if (transactions.length === 0) {
      throw new Error("No revenue generated by book: " + bookName);
    }

    const totalRevenue: number = transactions.reduce(
      (acc: number, transaction: any) => {
        return acc + (transaction.totalRent || 0);
      },
      0
    );

    return totalRevenue;
  } catch (error: any) {
    console.error("Error calculating book revenue: ", error.message);
    throw error;
  }
};

/**
 * Retrieves the list of books issued to a specific user.
 *
 * @param userIdOrName - The ID or name of the user to find books for
 * @returns An array of books issued to the user
 * @throws Error if the books cannot be retrieved
 */
const getBooksIssuedToUser = async (userIdOrName: string) => {
  try {
    const user = await userService.findOneByNameOrId(userIdOrName);
    if (!user) {
      throw new Error("User not found");
    }

    const transactions: any = await Transaction.find({
      userId: user._id,
    }).populate("bookId");
    return transactions.map((transaction: any) => ({
      bookName: transaction.bookId.bookName,
      issueDate: transaction.issueDate,
      returnDate: transaction.returnDate,
    }));
  } catch (error: any) {
    throw new Error(`Unable to retrieve books for user: ${error.message}`);
  }
};

/**
 * Retrieves the list of books issued within a specified date range.
 *
 * @param startDate - The start date of the range
 * @param endDate - The end date of the range
 * @returns An array of books issued within the date range
 * @throws Error if the books cannot be retrieved
 */
const getBooksIssuedInDateRange = async (startDate: Date, endDate: Date) => {
  try {
    const transactions: any = await Transaction.find({
      issueDate: { $gte: startDate, $lte: endDate },
    }).populate("bookId userId");

    return transactions.map((transaction: any) => ({
      bookName: transaction.bookId.bookName,
      issuedTo: transaction.userId.name,
      issueDate: transaction.issueDate,
    }));
  } catch (error: any) {
    throw new Error(
      `Unable to retrieve books for date range: ${error.message}`
    );
  }
};

/**
 * Helper function to calculate total rent based on issue and return dates.
 *
 * @param issueDate - The date the book was issued
 * @param returnDate - The date the book was returned
 * @param rentPerDay - The daily rent rate for the book
 * @returns The total rent calculated for the rental period
 */
const calculateTotalRent = (
  issueDate: Date,
  returnDate: Date,
  rentPerDay: number
): number => {
  const daysRented = Math.ceil(
    (returnDate.getTime() - issueDate.getTime()) / (1000 * 3600 * 24)
  );
  return daysRented * rentPerDay;
};

/**
 * Creates dummy transactions for testing purposes by issuing and returning books.
 *
 * @returns An object containing arrays of issued and returned transactions
 */
const createDummyTransations = async () => {
  const books = await bookService.findBooks();
  const users = await userService.getAllUsers();

  const generateIssueDate = (): Date => {
    return new Date();
  };

  const transactions: IIssueBook[] = [];
  const returnTransactions: IReturnBook[] = [];

  for (let i = 0; i < 40; i++) {
    const book = books[i % books.length];
    const user = users[i % users.length];
    const issueDate = generateIssueDate();

    const issueTransaction: IIssueBook = {
      bookName: book.bookName,
      userIdOrName: user.name,
      issueDate: issueDate,
    };

    const returnTransaction: IReturnBook = {
      bookName: book.bookName,
      userIdOrName: user.name,
      returnDate: new Date(issueDate.getTime() + 7 * 24 * 60 * 60 * 1000),
    };

    const issuedTransaction: any = await issueBook(issueTransaction);
    const returnedTransaction: any = await returnBook(returnTransaction);

    transactions.push(issuedTransaction);
    returnTransactions.push(returnTransaction);
  }

  return { transactions, returnTransactions };
};

// Export the service functions for use in controllers
export default {
  issueBook,
  returnBook,
  createDummyTransations,
  bookStatus,
  bookRevenue,
  getBooksIssuedInDateRange,
  getBooksIssuedToUser,
};
