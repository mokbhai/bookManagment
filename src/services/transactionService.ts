// src/services/transactionService.ts
import Transaction from "../models/transaction";
import bookService from "./bookService";
import userService from "./userService";

interface IIssueBook {
  bookName: string;
  userIdOrName: string;
  issueDate: Date;
}

const issueBook = async (data: IIssueBook) => {
  try {
    // Find the book by name
    const book = await bookService.findOneByName(data.bookName);

    // Find the user by userId or name
    const user = await userService.findOneByNameOrId(data.userIdOrName);

    // Create a new transaction
    const transaction = new Transaction({
      bookId: book._id,
      userId: user._id,
      issueDate: new Date(data.issueDate),
    });

    await transaction.save();
    return transaction;
  } catch (error: any) {
    throw new Error(`Unable to issue book: ${error.message}`);
  }
};

interface IReturnBook {
  bookName: string;
  userIdOrName: string;
  returnDate: Date;
}

const returnBook = async (data: IReturnBook) => {
  try {
    // Find the book by name
    const book = await bookService.findOneByName(data.bookName);

    // Find the user by userId or name
    const user = await userService.findOneByNameOrId(data.userIdOrName);

    // find transaction
    const transaction = await Transaction.findOne({
      bookId: book._id,
      userId: user._id,
      returnDate: { $exists: false }, // Ensure the book hasn't been returned yet
    });

    if (!transaction) {
      throw new Error("Transaction not found or book already returned");
    }

    transaction.returnDate = new Date();
    transaction.totalRent = calculateTotalRent(
      transaction.issueDate,
      transaction.returnDate,
      book.rentPerDay
    );

    await transaction.save();
    return transaction;
  } catch (error: any) {
    throw new Error(`Unable to return book: ${error.message}`);
  }
};

const bookStatus = async (bookName: string) => {
  if (!bookName) {
    throw new Error("Book name is required");
  }
  try {
    // Find all transactions for the given book name
    const book = await bookService.findOneByName(bookName);
    const transactions = await Transaction.find({ bookId: book._id });

    if (transactions.length === 0)
      throw new Error("No transactions found for this book: " + bookName);

    // Find currently issued transaction (where returnDate is null)
    const currentlyIssued = transactions.find(
      (transaction) => !transaction.returnDate
    );

    // Get list of all users who have issued the book
    const usersWhoIssued = transactions.map(
      (transaction) => transaction.userId
    );

    return {
      totalIssuedCount: transactions.length,
      currentlyIssued: currentlyIssued
        ? currentlyIssued.userId
        : "Not issued at the moment",
      usersWhoIssued,
    };
  } catch (error: any) {
    throw new Error("Error in fetching bookStatus: " + error.message);
  }
};

const bookRevenue = async (bookName: string) => {
  if (!bookName) {
    throw new Error("Book name is required");
  }
  try {
    // Find the book by name
    const book = await bookService.findOneByName(bookName);
    if (!book) {
      throw new Error("Book not found: " + bookName);
    }

    // Find all transactions for the given book ID
    const transactions = await Transaction.find({ bookId: book._id });

    if (transactions.length === 0) {
      throw new Error("No revenue generated by book: " + bookName);
    }

    // Calculate total revenue
    const totalRevenue: number = transactions.reduce((acc, transaction) => {
      return acc + (transaction.totalRent || 0);
    }, 0);

    return totalRevenue;
  } catch (error: any) {
    console.error("Error calculating book revenue: ", error.message);
    throw error;
  }
};

const getBooksIssuedToUser = async (userIdOrName: string) => {
  try {
    const user = await userService.findOneByNameOrId(userIdOrName);
    if (!user) {
      throw new Error("User not found");
    }

    const transactions = await Transaction.find({ userId: user._id }).populate(
      "bookId"
    );
    return transactions.map((transaction) => ({
      bookName: transaction.bookId.bookName,
      issueDate: transaction.issueDate,
      returnDate: transaction.returnDate,
    }));
  } catch (error: any) {
    throw new Error(`Unable to retrieve books for user: ${error.message}`);
  }
};

const getBooksIssuedInDateRange = async (startDate: Date, endDate: Date) => {
  try {
    const transactions = await Transaction.find({
      issueDate: { $gte: startDate, $lte: endDate },
    }).populate("bookId userId");

    return transactions.map((transaction) => ({
      bookName: transaction.bookId.bookName,
      issuedTo: transaction.userId.name,
      issueDate: transaction.issueDate,
    }));
  } catch (error: any) {
    throw new Error(
      `Unable to retrieve books for date range: ${error.message}`
    );
  }
};

// Helper function to calculate total rent
const calculateTotalRent = (
  issueDate: Date,
  returnDate: Date,
  rentPerDay: number
): number => {
  const daysRented = Math.ceil(
    (returnDate.getTime() - issueDate.getTime()) / (1000 * 3600 * 24)
  );
  return daysRented * rentPerDay;
};

// If you want to create some dummy transactions (i.e issue books and return them)
const createDummyTransations = async () => {
  const books = await bookService.findBooks();

  const users = await userService.getAllUsers();

  const generateIssueDate = (): Date => {
    return new Date();
  };

  const transactions: IIssueBook[] = [];
  const returnTransactions: IReturnBook[] = [];

  for (let i = 0; i < 40; i++) {
    const book = books[i % books.length];
    const user = users[i % users.length];
    const issueDate = generateIssueDate();

    const issueTransaction: IIssueBook = {
      bookName: book.bookName,
      userIdOrName: user.name,
      issueDate: issueDate,
    };

    const returnTransaction: IReturnBook = {
      bookName: book.bookName,
      userIdOrName: user.name,
      returnDate: new Date(issueDate.getTime() + 7 * 24 * 60 * 60 * 1000), // Assuming a 7-day rental period
    };

    const issuedTransaction: any = await issueBook(issueTransaction);
    const returnedTransaction: any = await returnBook(returnTransaction);

    transactions.push(issuedTransaction);
    returnTransactions.push(returnedTransaction);
  }

  return { transactions, returnTransactions };
};

export default {
  issueBook,
  returnBook,
  createDummyTransations,
  bookStatus,
  bookRevenue,
  getBooksIssuedInDateRange,
  getBooksIssuedToUser,
};
